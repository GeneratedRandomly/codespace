## 代码一
~~~
RE
~~~
#### 原因
`play(left - 1)`可能造成`rank`等于`-1`而调用`a.at(rank)`时越界。
#### 输入
~~~
ACCBA
5
1 B
0 A
2 B
4 C
0 A
~~~
#### 输出
~~~
terminate called after throwing an instance of 'std::out_of_range'
what():  basic_string::at: __n (which is 18446744073709551615) >= this->size() (which is 0)
~~~
#### 构造思路
让某次插入所消除的部分正好包括字符串第一个字符即可，这样就有left为0，从而触发a.at(-1)。
## 代码二
~~~
RE
~~~
#### 原因
字符串a为空时可能调取`a.at(rank)`且`rank`等于0，从而越界。
#### 输入
~~~
ACCBA
5
1 B
0 A
2 B
4 C
0 A
~~~
#### 输出
~~~
terminate called after throwing an instance of 'std::out_of_range'
what():  basic_string::at: __n (which is 18446744073709551615) >= this->size() (which is 0)
~~~
#### 构造思路
~~~
让某次祖玛插入后所有祖玛珠都被消除即可。由于程序要消除到发现无法再消除，故而肯定会对空串访问a.at(0)
~~~
## 代码三
~~~
TLE
~~~
#### 原因
只要过长就可能触发这个问题，因为本算法是`O(n*m)`的（每次插入造成的移动是`O(n)`，共有`m`次插入）。
#### 输入
`03.in`
#### 构造思路
足够长即可，使用随机生成器。
## 代码四
~~~
WA
~~~
#### 原因
`left`有可能和`a.at(rank)`的颜色不同，但每次必被消除。
#### 输入
~~~
BAABB
1
1 A
~~~
#### 输出
~~~
BB
~~~
#### 构造思路
让被消除的三个珠子不在最左端，就会导致它们仨左侧的字符神秘消失。本构造右侧的BB不是必须的，但是可以让错误更加明显。
## 代码五
~~~
WA
~~~
#### 原因
`cin`无法输入空祖玛串。
#### 输入
~~~

1
0 A
~~~
#### 输出
~~~
1
~~~
#### 构造思路
初始字符串为空即可。`cin`把祖玛串设定为`"1"`，`m`设置为`0`。
## 代码六
~~~
WA
~~~
#### 原因
块过长时不重组，`plen`数组里存储的`p`长度与实际不符，在使用时`l`和`r`等做的运算是错误的，数组移动位置不能达到想要的结果。
#### 输入
`06.in`
#### 构造思路
初始构造一个很长的串，会被分成多块；在前1000个位置插入数千个字符，以扩张第一块并使之超过限额。
## 代码七
~~~
WA
~~~
#### 原因
`play`函数中96行附近
~~~
93   while (l.first >= 0 && get(l) == ch) {
94         l.second--;
95       dis++;
96       if (l.second < 0 && l.first >= 0) {
97             l.first--;
98           if (l.first >= 0) l.second += plen[l.first];
99       }
100   }
~~~
既然`p`是分块数组，这里就应该让之前的块把`l.second`的负值抹平，如果前一块很小，不足以抹平这个负值，也就是连消会整体越过一块，就会造成错误。
#### 输入
`07.in`
#### 构造思路
一共四块：`CCDDCCDD...`、`AABBAABB...`、`AABBAABB...`、`CCDDCCDD...`。先在正中间插入`A`，第一、四块不变，第二块变为`AA`，第三块空。然后再在第四块左边插入`A`。理论上应该消除第二块，只留下原封不动的第一、四块；但由于用了`if`而不是`while`，不会“查看”第二块，直接
~~~
l.first--; //l.first = 1
l.second += plen[l.first]; //l.second += 0
~~~
就完事了，代码会认为这个`A`左右两侧没有相同颜色的珠子，不消除，造成错误。
## 代码八
~~~
WA
~~~
#### 原因
没有考虑连消。
#### 输入
~~~
AABBAB
1
2 B
~~~
#### 输出
~~~
AAAB
~~~
#### 构造思路
构造连消情况即可，直接参考OJ样例。
## 代码九
~~~
RE
~~~
#### 原因
如果`l.first == r.first`，“执行消除”部分代码就会在`plen`中把`p[l.first]`只保留到第`l.second`位，下一个开始全都删掉。消除完毕后，$plen[r.first] == len == plen[r.first] - r.second == l.second + 1 - r.second < 0$。而`plen`是`size_t`无符号，会溢出为一特别大的数，被识别为块过长，需要重组，从而执行`p2a`，`memcpy`会数组越界。
#### 输入
~~~
ABBCC
1
1 B
~~~
#### 输出
~~~
Segmentation fault
~~~
#### 构造思路
设置一个较短的字符串，可以保证在同一个块数组里进行消除即可引发溢出。
## 代码十
~~~
WA
~~~
#### 原因
“执行消除”部分代码最尾部的循环变量从`l.first`开始，将`plen[l.first]`也错误地设置为`0`。只要有某次祖玛操作改变了多个块，就会进入分支而触发这一问题。
#### 输入
`10.in`（只包含`A、B、C`的字符串，每次插入只插入这三个字母其一）
#### 构造思路
随机构造高重复率的中等长度字符串，字符串会被分成多块，且容易产生比较长的连消，从而增加连消分布在相邻块的可能性，以实现错误。