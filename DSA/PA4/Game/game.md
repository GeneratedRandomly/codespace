## 算法思路和实现要点
算法思路
- 初始化：
  - 读取节点数 `N` 和边数 `M`。
  - 读取每个节点的时间 `t[i]`。
  - 构建图的邻接表 `adj`，同时插入$(u,v)$和$(v,u)$两条边。`vector`是自己实现的。
  - 设置初始值：
    - 初始化 `min_time` 数组为`0x3f3f3f3f`，是可以算作无穷大不会溢出的大数，表示每个节点的最短时间。
    - 初始化 `ways` 数组为`0`，表示到达每个节点的路径数。这个要用来动态规划。
    - 初始化 `visited` 数组为 `false`，表示每个节点是否被访问过。
  - 起点设置：
    - 设置起点节点1的最短时间为 `t[1]`，路径数为`1`。
    - 将起点节点1加入优先队列 `q`。优先队列的每个元素有`time`，也就是其$priority$；还有`index`，也就是节点的索引，用来找这个节点通向的点。  
- `Dijkstra`算法：
  - 当优先队列 `q` 不为空时，执行以下步骤：
    - 取出当前路径最短的点 `u`，如果节点 u 已经被访问过（也就是从未确定的T集合进入已确定最短路径的S集合）。
    - 标记节点 `u` 为已访问。
    - 遍历节点 `u` 的所有邻接节点 `v`：
        - 如果通过 `u` 到达 `v` 的时间比当前记录的最短时间更短，则更新 `v` 的最短时间，并修改路径数（之前的路径被废除）。
        - 如果通过 `u` 到达 `v` 的时间等于当前记录的最短时间，则累加路径数（之前的路径和本路径一样长）。
## 渐进时间复杂度的分析，包含过程
除了必要的输入时间复杂度$O(r)$以外，每松弛一条边$(u,v)$，就把$v$插入堆，最多会插$m$次，每次的复杂度$O(\log n)$，每次删除堆顶，最多删除$m$次（其实$n$次应该就行），所以总共的时间复杂度为$O(m\log n)$。
## 渐进空间复杂度的分析，包含过程
这里除了`adj`，其它的大小都是定死了的，总共有$O(MAXN+MAXM)$的空间复杂度；而`vector adj`是邻接表，从而有$O(M)$的空间复杂度。总共的空间复杂度为$O(MAXN+MAXM)$。
~~~cpp
int t[MAXN + 1];
vector adj[MAXN + 1];
int min_time[MAXN + 1];
int ways[MAXN + 1];
bool visited[MAXN + 1];
PriorityQueue q(MAXM + 10);
~~~
## 遇到的困难和解决方法
死活de不出来bug，最终只能求助于同学，用了对拍，用小规模输入才发现原来我加边的时候只加了一个方向。
## 估计完成本题所用时间
5h
## 关于本题的更多感想
debug太痛苦了，悲。