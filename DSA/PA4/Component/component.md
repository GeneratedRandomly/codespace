注：`dsu`指并查集，`pdd`指配对堆
## 算法思路和实现要点
我们在一个`n`大`dsu`里包含一个`n`大`pdd`，并查集实现路径压缩和启发式合并（节点少的当儿子），维护每个节点父亲的索引`father`、所在并查集中以自身为根节点的子树的大小`dsusize`，所在并查集对应的配对堆中以自身为根节点的子树大小`pddsize`、所在并查集对应的配对堆根节点在配对堆中的索引`pddroot`（实际上我们只能保证并查集根节点维护的`pddroot`是正确的，其他节点的`pddroot`都很有可能是错误的，所以我们用并查集根节点维护的`pddroot`当作整个连通分量配对堆的根节点位置）。  
配对堆保证父亲的权重大于孩子的权重，实现合并（把权值小的堆当成权值大的堆的孩子）、取得最小值（返回根节点权值）、删除最小值（把最小值的长子拿出来，它和它的弟弟合并，这称为`m`操作；然后对它弟弟的弟弟做`m`操作，再把返回的根节点和它与它弟弟的合并堆合并，也就是把最小值的孩子们拆散，从左往右两两合并，再把合并的小堆从右往左合并起来，这才能保证$O(\log n)$。  
在并查集中维护配对堆最多`k`个：合并时我们找每个节点所在并查集的根节点，取这个根节点保存的本连通分量对应配对堆的顶`pddroot`以及大小`pddsize`，然后我们把两个连通分量对应配对堆的大小之和和`k`比较，如果比k大就找两个配对堆中顶较小的一个堆（假设这个配对堆对应并查集顶为`a`），删除这个堆的顶，`delete_min`返回新的根位置，赋值给`a`保存的跟位置，并把`a`保存的本分量配对堆大小减一，直到两个连通分量对应的配对堆大小之和到达`k`为止。
## 渐进时间复杂度的分析，包含过程
`dsu`使用了路径压缩和启发式合并，除了`merge`以外每个操作时间近似$O(1)$；  
`pdd`的`merge`是$O(1)$，`delete_min`是均摊$O(\log n)$，可见[配对堆 - 维基百科](https://zh.wikipedia.org/zh-cn/配对堆)。  
`dsu`的`mergedsu`给整个程序带来的复杂度：`mergedsu`最多把`n`个`1`大配对堆变成`1`个`k`大配对堆，每减少一个配对堆元素耗时$O(\log n)$，最后`mergepdd`为$O(1)$，总共的时间复杂度上界$O((n-k)\log n)$。
综上，总共的时间复杂度上界$O((n-k)\log n+q)$。
## 渐进空间复杂度的分析，包含过程
`dsu`里开了`4`个`n`长数组，`pdd`里开了`1`个`n`长数组，总空间复杂度为$O(n)$。
## 遇到的困难和解决方法
本来打算配对堆和并查集独立，并查集里面给每个点维护一个指向其所在连通分量对应配对堆堆顶的指针，后来发现行不通，咨询copilot，改为配对堆维护最少信息（权值、长子、弟弟），并查集里给每个点所在连通分量顶维护一个本连通分量配对堆的位置。
## 估计完成本题所用时间
3h
## 关于本题的更多感想
配对堆感觉比左式堆好写不少，建议推广（）