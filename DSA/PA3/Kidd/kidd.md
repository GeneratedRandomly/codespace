## 算法思路和实现要点
每个节点存左右孩子、翻转次数和懒惰标记。开始时，只有根节点`node[root==1]`。  
- 每次翻转时，会从根节点不断下探。如果这个节点不存在，就建立节点，方法是维护当前最大节点`idx`，`i = ++idx`，由于引用传参，这个节点如果是递归传下来的某个节点的孩子，在这层就能给上一层节点建子节点。  
然后，如果当前节点的区间是翻转区间的子集，直接给区间和加上`end-start`（左闭右开），懒惰节点加一（就不改孩子了）。  
否则，就算出当前节点左右的中间（这样计算，保证每个节点在翻转和查询时的左右区间是一定的，所以不需要存储），然后把区间和、懒惰标记下传（因为需要孩子出场了）。`pushdown`之后，看看翻转区间和左右子节点各自的区间有没有交集（根据左闭右开，直接大于或小于就行），有交集就递归翻转。因为还没改区间和，所以要用孩子的区间和之和赋值给自己。  
- 每次查询时，从根节点下探，如果没有这个节点，就返回0；  
如果节点区间是查询区间的子集，就返回当前节点的区间和；  
否则，算出当前节点区间的中间。同理，先`pushdown`，再递归查询即可。
`pushdown`：如果没有孩子就建孩子，然后把区间和按孩子大小复制下去，懒惰标记直接剪切下去。
## 渐进时间复杂度的分析，包含过程
每次翻转和查询都是$O(logn)$的，但这个$n$和$2^{31}$那个不同，是实际上的节点数量。最坏情况，根据静态线段树的分析，节点数量应该是$O(mlogm)$的，所以总共的时间复杂度在$O(mlog^2m)$。
## 渐进空间复杂度的分析，包含过程
固定开了$10700000$，占用空间$255300kb$，与数据规模无关。
## 遇到的困难和解决方法
遇到的困难都是围绕着$n<2^{31}$，首先使用指针动态开点，但仍然`MLE`，改成数组紧凑表示了，经过多次提交尝试发现开$10700000$个`treenode`正好。
## 估计完成本题所用时间
5h
## 关于本题的更多感想
还是需要交流和多学习文献，会给代码能力以很大提高。