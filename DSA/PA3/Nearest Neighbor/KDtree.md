## 算法思路和实现要点
每个节点存一个向量（点）和两个孩子的指针。首先保存所有输入的向量到`points`。  
### 建树：  
每个节点代表一个超长方体。  
把空间所有点按照第一维度快速选择，使中位数居中，其左比中位数小，其右比中位数大。  
建立一个节点，保存这个中位数所对应的点，节点左右孩子是过该点、且被垂直于这个维度的$d-1$维超平面剖分的两个超长方体。  
递归建立子节点，传递的深度参数加一，下一层就会用下一维度。  
### 建树用到的快速选择：  
先定义一个`partition`函数，以数组最后一个数为枢轴，用`i`维护可能比枢轴大的第一个数的位置，然后遍历数组，只要有比枢轴小的数就和`i`处的数交换，使得比枢轴小的数稳定地排到左边来，然后把枢轴换到正确的位置。  
这样做，数组最后一个数若为第`i`小，则成为数组第`i`个数，左边比它小，右边比它大。  
快速排序只需要每次看这个`i`和中位数（$n/2$）的关系，如果`i`太大了就排`i`左边部分的数组，反之同理，直到`i`恰为索引中位，就可以保证中位数居中、左小右大。
### 查询：  
考虑数据规模，每逢乘方开`long long`。  
我们从`node`开始下探，传入查询向量。查询时保证每一层的维度和建树时的维度是一样的，且用当前向量和查询向量的距离更新最小距离。  
现在我们有两个子树，要决定剪枝方案。  
首先应该搜索在这个维度上和查询向量在同一边的子树，这个子树更可能离查询向量要近。  
另一个子树是否要搜索？实际上另一个子树有可能包含离查询向量更近的点（极端的情况，其中可能有个向量的所有分量都和查询向量一致，只有这个维度上和查询向量差2，中间正好是当前点），所以也要搜索。  
那剪枝条件如何？当目前节点和查询向量在这个维度上的分量距离平方已经大于等于最小距离了，那查询向量另一边的子树上的向量与当前向量在这个维度上的分量距离平方也会大于等于最小距离，从而那些向量与当前向量的欧氏距离就会大于等于最小距离，所以不用看了，可以剪枝。
## 渐进时间复杂度的分析，包含过程
### 建树：
$T(n)=2T(n/2)+O(n)=O(n\log n)$，这是由于快速选择平均复杂度为$O(n)$。  
### 查询：
直接推广课上的讨论，扩张PPT中2d树的2和4这两个2的幂，可得$T(n)=2^{d-1}T(n/2^d)+O(1)=O(n^{1-\frac{1}{d}})$。
## 渐进空间复杂度的分析，包含过程
我的每个`kdnode`节点都保存了一个空间中的点（向量），所以空间复杂度是$O(n)$。
## 遇到的困难和解决方法
`sort`和`nth_element`不能用，于是就自己实现了快速选择算法，把中位数排到中间去。
## 估计完成本题所用时间
7h
## 关于本题的更多感想
copilot可以让程序员事半功倍，无论是在本课程还是在软件工程课程都有同感。  
要理解算法本质，比如kd树是对空间进行划分，分成超长方体。