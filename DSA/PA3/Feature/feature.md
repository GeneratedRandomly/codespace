## 算法思路和实现要点
首先实现一个`AVL`树，然后修改即可。  
我们的第一棵树包含权`w`和值`x`，称为`w`树，第二棵树包含`w`、`x`和以当前节点为根的子树的总$y_{this}=w_{this}*x_{this}+y_{this->leftchild}+y_{this->rightchild}$（变量`sum`），称为`wabs`树。由于`wabs`树有了`sum`，所以`update`时也要修改`sum`。  
初始化时，只需要保存整个`const int *w`的副本，并且将每个`w-x`对`insert`进树即可。要注意，由于`calculate`的“绝对值`k`大”要求，所以`wabs`树在`insert`辨析进入左子树还是右子树时，比较的不是`node->w`和`data->w`，而是比较二者的绝对值。  
在按`i`修改`w`时，首先要从保存的`const int *w`里找对应的`w`，再在两棵树里都`remove`对应权重的节点。但还要存储那个节点的`x`值，并且通过`getx`取出来，为了和新`w`组合起来`insert`进两棵树。  
在修改第`k`大`w`对应的`x`时，首先，要从`w`树里找到第`k`大`w`所在的节点。每次比较`k`和当前节点右子树的`size`（可以称为`rsize`），如果`k==rsize+1`（`1`代表本节点）则正好返回指向本节点的指针，`k`较小就直接进入右子树，`k`较大就进入左子树，`k`需要减去`rsize+1`。我们获取指针之后，直接修改`x`，然后取得`w`；在`wabs`树里，我们先保存一个$delta=w*\Delta x$，然后递归搜索`w`，搜到了就修改`x`，利用递归性质，修改一路上（修改节点及其父亲以至于根）节点的`sum`（加上`delta`即可）。
取`abs(w)`最大的`k`个`w`时，我们直接从根出发，类似上面在`w`树里进行`k`大搜索的过程，在`wabs`树进行`k`大搜索。如果`k`在右子树，就进入右子树；如果`k`是本节点，`sum`就要加上比本节点大的那些没有被搜过的点的$w*x$，也就是本节点及其右子树的总$w*x$之和，也就是本节点`sum`减去其左子树的`sum`。如果`k`在左节点，除了要同样地增加`sum`，还要类似`w`树进入左子树。
## 渐进时间复杂度的分析，包含过程
每个函数都会执行$O(1)$次以下函数（之一或之几个）：`insert`、`remove`、`getx`、`findKth`、`modifyByWeight`。其中`insert`和`remove`与AVL的插入删除没什么区别，都是$O(h)=O(\log n)$的；`getx`是个$O(1)$的，`findKth`和`modifyByWeight`也是左右子树其一递归的$O(h)=O(\log n)$的函数，所以总共的时间复杂度是$O(m\log n)$。
## 渐进空间复杂度的分析，包含过程
每个权值对会在两棵树里各创造一个节点，所以空间复杂度是$O(n)$的。
## 遇到的困难和解决方法
AVL树一时难以下手，copilot提供了参考代码并仔细给我剖析讲解。
debug也比较困难，只能自己努力去找，并且写了个对拍。
## 估计完成本题所用时间
15h
## 关于本题的更多感想
debug太痛苦了，小小的问题就会造成大大的后果，如果程序运行的时候溢出有提示就好了。