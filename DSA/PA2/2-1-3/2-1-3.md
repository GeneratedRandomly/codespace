## 算法思路和实现要点
题目所说“活跃期”条件即保证了股票退市和入市的顺序是一致的。为此可以使用一个队列按顺序存储股票的持股量。题目所求的计算方法是，我们记录自己手上的持股量，每次读取日期和新持股量，按持股量大小考虑是否更换持股，同时把这个持股量存储起来；每次退市，我们删除队列的第一个持股量，如果所删除的是我们手上所持的股票，就要在队列里寻找最大的持股量，进行持股。每次读取时，都应把累计持股量（即所求）加上一个原有持股量*经过天数。那么，困难之处就在于每次从队列中寻找最大持股量。我们维护一个记录“可能成为最大持股量”的持股量队列，每次新的股票入市，新的持股量本应放在这个队列尾端，但如果这个位置前面还有比它更小的持股量，那些持股量是肯定不会成为最大持股量的，就需要从队列里面清除出去。只要贯彻这个原则，那队列是单调递减的（不必也不能严格），所以不怕漏删靠前的小持股量记录。每次股票退市，就要看是否是我们手上所持的最大持股量（在此队列首），若是，也要将其清除。每次取所有现存的持股量最大值，就从这个队列首取就好。

考虑到本题最多也就`n`次记录，我用数组设计了一次性`deque`。
## 渐进时间复杂度的分析，包含过程
一共有`O(n)`个输入，每次输入可能导致的操作中，`pop`和`getmax`都是`O(1)`的，而`push`虽然某些时候可能会消耗较长时间，但考虑到每个持股量最多进入“可能成为最大持股量”队列一次，出队列一次，所以平均下来也是`O(1)`的。所以总时间复杂度是`O(n)`。
## 渐进空间复杂度的分析，包含过程
每个`deque`用`O(n)`的空间，其他都是常数，所以总空间复杂度是`O(n)`。
## 遇到的困难和解决方法
`getmax`函数不会写，了解了“单调队列”的知识之后才明白。
## 估计完成本题所用时间 
`2h`
## 关于本题的更多感想
QAQ好像还没学`queap`。