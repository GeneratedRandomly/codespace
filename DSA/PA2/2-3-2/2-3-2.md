## 算法思路和实现要点
我们首先设置每个节点存储自己的高度、规模和父亲节点、孩子节点的信息，节点不用指针，用数组模拟指针即可。开一个$10^6$大小的全局数组，作为节点。同时类似课程PPT实现一个`vector`，用来装每个节点的孩子。为了实现$O(cost)$，这个`vector`应该是反向的，也就是`vector`中`data[0]`装的是最后一个孩子。这是因为每次插入删除的时候只会移动`data`中在变化位置以后的部分，而$O(cost)$的定义是从哥哥向弟弟的，所以需要让哥哥移动，不让弟弟移动。我们进行类似`size - index`的映射即可，在`insert`、`remove`、`operator[]`中都更改。  
然后我们初始化这棵树，对每行扫一遍：开一个孩子个数长度的`tmp`数组，每次输入一个孩子节点，将孩子编号存到`tmp`里面，并且将孩子节点的父亲设置为这行的节点编号。最后把`tmp`逆序简单粗暴的按`data`（非`vector`！！！）顺序`push_back_unsafe`。然后递归设置每个节点的高度和规模，即每个节点只需要用孩子们的规模和高度设置自己的规模和高度。  
然后每次按照操作数，进入`move` `get_height` `get_size`三者之一。定义一个`get_index_by_scanf`，可以返回节点编号（先按照所给孩子下探，下探失败就清空整行并退出）。`get_height` `get_size`简单粗暴即可。`move`需要先获取子节点，切掉之，获取父节点及插入位置，将子节点连接到父节点的插入位置。切掉（`cut`）和连接（`link`）大同小异，首先都是简单地修改父节点的高度和规模，然后递归上探修改高度（使用函数`recursive_set_height`），然后迭代设置规模。  `recursive_set_height`中，如果孩子的高度没改变，就应该返回，不再进行后续修改了；我们分孩子高度变小（`cut`）和孩子高度变大（`link`）两种情况，而这两种情况差不多：首先看看孩子高度的变化会不会导致父亲高度的变化，即孩子是否decisive；如果不decisive就返回（`cut`里如果不decisive还要用兄弟们修改父亲的高度）。当孩子decisive，上探迭代修改高度。
## 渐进时间复杂度的分析，包含过程
- 初始化：在每个父亲加入其所有孩子，每个孩子链接其父亲，复杂度应该在$O(edge)=O(n*averageSonNumber)<O(输入数字总数)$。  
- `move`：$O(cut)+O(link)$  
$O(cut)=O(最后一个有效的输入数字，即其所占成本)+O($`recursive_set_height`$)+O(本层兄弟个数)+O(level，迭代部分)$；  
$O(link)=O(1)+O($`recursive_set_height`$)+O(level)$；  
$O($`recursive_set_height`$)$的复杂度：最坏情况是，不会提前返回 ，必须到根； 每次都要遍历所有兄弟，从最底层开始，最坏复杂度是$O(n)$的；  
所以`move`的复杂度即$O($`recursive_set_height`$)+O(level)=O(n)$；  
但是`vector`的`operator[]`是$O(1)$的，插入删除都是$O(cost)$的，所以很快，能过。
- `get_height`：$O(一行数字个数)+O(1)取height<O(一行数字总和)=O(其所占成本)$，由`get_index_by_scanf`保证。
- `get_size`：$O(一行数字个数)+O(1)取size<O(一行数字总和)=O(其所占成本)$，由`get_index_by_scanf`保证。
## 渐进空间复杂度的分析，包含过程
我开了一个$10^6$的数组，每个节点又都有一个初始$O(1)$大小的`vector`装孩子，所以应该是$O(\Sigma_{i=1}^n sonAmount_i)=O(输入)$。
## 遇到的困难和解决方法
一开始用了指针，各种出问题，修了好久修不好，痛苦难言，后来全用数组模拟指针，好多了。移动子树难难难，`cut`和`link`搞不太懂，只能慢慢磨。后来把他俩的迭代设置高度改成递归，也好多了。最后又出问题了，查出来是输入部分写的防范措施不起作用，才有了string清零本行的办法。
## 估计完成本题所用时间
15h
## 关于本题的更多感想
难难难，最后居然过了是我没想到的