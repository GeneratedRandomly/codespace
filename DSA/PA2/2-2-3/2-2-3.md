## 算法思路和实现要点
#### 不变性证明
在不变性已经满足的情况下：
1. 情况1：现在栈中只剩下$v_{i-1}$和$v_i$，二者之间自然形成优链；$v_i$左侧只剩下$v_{i-1}$发出的另一条边，其右端点显然在$v_i$右侧（不然最新处理的就不是$v_i$了），不变性仍然满足。
2. 情况2
   1. 整个栈中从栈底到$v_i$的元素形成一条单调优链，而从栈底倒数第二个元素到栈顶倒数第二个元素的所有两条邻边都在这条链上，所以$v_i$左侧还没讨论的边只有从栈底发出，到现在还没触及到的、$v_i$右侧端点，不变性仍然满足。
   2. 在这步执行完后，或者栈中只有两个节点而自动成为优链，或变成2.1的情况（从栈底到$v_i$是优链的话只可能是这一情况），否则既然栈中元素不组成优链，而且栈中又有大于等于两个元素，那栈顶元素肯定是劣节点，从而没有执行完，所以不可能出现这种情况。因此不变性仍然满足。
#### 要点
对每个点，设置其`x`、`y`、所在链。在加入过程中，由逆时针可知，若该点`x`比上一点`x`小，则属于上面一条链，反之亦然，只有首尾端点的所在链属性是没有实际意义的。但我们一开始就把前两点放进栈，而且容易证明每个操作之后栈里还剩至少两个元素，所以首端点的所在链被掩盖了；而对于最后一个端点也不用特殊处理：如果其链属性与倒数第二个点相反，进入情况1，显然是没问题的；进入2.1，则这个优链早就会被处理掉，否则与简单性冲突；进入2.2，也没问题。所以不需要特殊处理。

在计算点的优劣性时，通过比较斜率，进行简单的处理就得到代码63行。对于上面的点（链属性为真），优节点显然是斜率越来越高的，反之亦然，所以有64行的判断。
## 渐进时间复杂度的分析，包含过程
进入情况1、2，都有一个while循环，但每个元素最多进栈一次，出栈一次，所以时间复杂度为$O(n)$。最前面有排序函数，时间复杂度为$O(n\log n)$。所以总的时间复杂度为$O(n\log n)$。
## 渐进空间复杂度的分析，包含过程
向量和栈中的元素个数都是$O(n)$，所以空间复杂度为$O(n)$。
## 遇到的困难和解决方法
无
## 估计完成本题所用时间
2小时
## 关于本题的更多感想
无