## 算法思路和实现要点
算法思路来源于思路提示，其中排序使用了归并排序，二分查找的实现要点是，每次考察`P`是否在第`m+1`条线的左边（这条线段数组下标是`m`），如果在就`r=m-1`并记ans=m，否则就l=m+1，因为如果m在线左，焦点数必然小于等于m，只需要考虑前m条线；如果在线上或线右，焦点数必然大于等于m+1，不用再考虑前m条线。此外，P在线段XY“左侧”，等价于以向量$\boldsymbol{}{YP}$为第一行、向量$\boldsymbol{YX}$为第二行的矩阵的行列式大于0（此即思路提示所说的叉乘法），可以化简为$x_m*y_m-x_m*p_y-y_m*p_x>0$，可见于代码中。
## 渐进时间复杂度的分析，包含过程
输入时间复杂度$O(n+m)$，输出时间复杂度$O(m)$，归并排序时间复杂度$O(nlogn)$，二分查找的时间复杂度$O(logn)$。所以总共的时间复杂度为$O(nlogn)$。注：归并排序中，$T(n)=2*T(\frac{n}{2})+O(n)$。由主定理最复杂那个情形可以得出归并排序的时间复杂度。
## 渐进空间复杂度的分析，包含过程
输入存储就需要$O(n+m)$大小空间，二分查找只需要常数个空间，归并排序在递归到底时会占用$O(logn)$个栈，但每个栈里，即归并排序同一层，并无新建变量，其`merge`函数只有在运行时才占用$O(r-l)$大小空间，最大只有$O(n)$，每向下递归一层，$O(r-l)$都会缩小一半，所以整个归并排序占用空间最大的时候也只有$O(n)$。综上，总共的空间复杂度为$O(n+m)$。
## 遇到的困难和解决方法
nope
## 估计完成本题所用时间 
1小时
## 关于本题的更多感想
思路提示太有帮助了*2。