## 算法思路和实现要点
根据题意，我们欲将一个`n`长字符串变为一个`m`长字符串。如果在`n`长字符串中有任意长度的子序列和`m`长字符串的某个同长子序列全同，那么就不用修改子序列这部分。最坏情况是两个字符串毫无相同子序列，那就需要删除全部`n`个字符，重写`m`个字符；否则，我们只需要更改不在相同子序列以外的部分，相同子序列部分在`A`中不用删、`B`中不用加，可以“减少两次操作”。所以最少需要`n+m-2*LCS(A,B)`次操作，其大于`k`时自然无解。我们用一个动态规划数组`dp[i][j]`来表示串`A`的前`i`个字符和串`B`的前`j`个字符的`LCS`。但`n`和`m`可能为501000，空间时间都会越界。考虑到`LCS(A的前i个字符,B的前j个字符)<min(i,j)`，当`i-j>k`或`j-i>k`时必然无解。对于每个`i`，只需要考虑`max(i-k,0)<=j<=min(i+k,m)`范围的`dp[i][j]`。而显然`LCS`的状态转移方程为`dp[0][0]=0; dp[i][j]=max(dp[i-1][j-1]+(A[i-1]==B[j-1]),dp[i-1][j],dp[i][j-1])`。我们运用状态压缩，只需要开一个`2k+1`长数组，代表`dp`一行的需要考虑范围内的数据，记录下来其左侧是从`0`还是`i-k`开始（即其偏移量）（右侧类似），每次从左往右计算（先将数组里原来的数存储起来，再进行计算），直到算到所需的`n`和`m`。当`i<=k`时不必然无解，不用偏移，直接由状态转移方程进行计算；当`i>k`时字符串`[B[0], B[i-k])`必然无解，需要偏移。偏移带来的结果：①`dp`数组中存在某一位置的`B`字符串字符存在偏移量`i-k`；②存储数组原来数字的变量，要从“更右一位”取数存储，以补偿每次加一的偏移量。最后从`dp`数组`m-偏移量`位置取数即为所求`LCS`。
## 渐进时间复杂度的分析，包含过程
先将`dp`数组清零为`O(n)`，再循环`n`次，每次有一个`min(i+k,m)-max(i-k,0)`，`m`足够大时，主要循环的时间复杂度为`O(n*k)`，而这是与数据范围相符合的。
## 渐进空间复杂度的分析，包含过程
除去输入输出必须，只开了一个数组`dp[2k+1]`，故空间复杂度`O(K)`。
## 遇到的困难和解决方法
太摆了导致效率低下，通过用ddl警告自己解决；偏移量的处理非常麻烦，通过数学计算和多次debug解决。
## 估计完成本题所用时间 
3小时
## 关于本题的更多感想
思路提示太有帮助了，把想出算法的任务简化为证明算法了。