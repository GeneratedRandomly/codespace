## 不同哈希策略的实现
注：$N$为表长，$p$取$151$，$str$为键字符串。
### 不均匀哈希
$hash=(str[0]+str[1]+\cdots+str[i]+\cdots+str[n-1])\%N$
### 均匀哈希
$hash=(str[0]*p^{n-1}+str[1]*p^{n-2}+\cdots+str[i]*p^{n-1-i}+\cdots+str[n-1])\%N$
### 双向平方试探
在对象中维护试探次数$i$，索引每次加上$(-1)^{i+1}*\lceil i/2\rceil^2$返回。如果小于$0$则加上表长，形如将表的后半部分接到开头前面；如探测次数超哈希表长，则视为表满（表长为$4k+3,k\isin\N$），返回$-1$.
### 公共溢出区
在插入和查询函数利用`dynamic_cast`判断为公共溢出区策略时，表长减去溢出区长传入。在本策略内部，在溢出区内从头到尾找到第一个空位返回。溢出区设置为$50000$.
### 公平声明
对原有框架的改动：  
1. `hash_entry`增加`int status`，为`enum{EMPTY, OCCUPIED}`其中之一，函数中相应地用以判空（替代原有的`my_string==NULL`判空）、设置`status`，不影响公平性。
2. `dynamic_cast<common_overflow*>`则传一个缩小表长，其他情况不变，这本就是哈希策略的一部分。
3. 在循环中设置了`if (last_choice == -1) return -1;`，表满时直接失败退出，也不影响公平。
## 进行测试
- 数据规模$50000$和$400000$，插入占总操作数比例$0.2$和$0.8$，先插再查和随机插查。  
- 查询的$1/3$为未插入字符串，$2/3$为已插入字符串。  
- 我使用`unordered_map`储存插入的字符串和数字，插入时会检查字符串是否已存在，从而确保每个映射最多插入一次。
- 同时用一个`vector`储存已插入的字符串，查询时随机从其中取字符串进行查询。即$2/3$部分。
- 未插入字符串的构造方法是，取已插入字符串结尾连接下划线和随机数，即$1/3$部分。  
- 测试时间结果见`result.md`。
## 分析结果
- 好哈希性能远比坏哈希强：哈希均匀，不会聚集，更容易一次命中空位插入，避免了不断循环`collision`。
- 在哈希不够均匀时，双向平方试探性能远比线性试探强，也是能规避聚集，减少碰撞。但哈希均匀时性能无优势，此时以计算耗时为主，双向平方试探时间复杂度比线性试探有常数劣势。
- 双向平方试探最占优势。在数据量不大、哈希碰撞少的情况下，公共溢出区适合使用，线性试探的聚集太过严重；数据量大，哈希函数比较好时，线性试探适合使用，因为计算量小，而且不用遍历。
- 字符非随机会导致哈希冲突的概率增加，造成性能下降。试想字符全同的极端情况即知。
- 思路同`vector`的`expand`和`shrink`倍扩倍缩再复制，实现均摊$O(1)$。